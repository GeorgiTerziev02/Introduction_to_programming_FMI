# Побитови операции 

## Задачи

1. Напишете функция, която приема цяло число и обръща най-десния бит в него, който е единица. <br />

   Вход: 12  | Изход: 8 <br />
   Вход: 15  | Изход: 14 <br />

2. Напишете функция, която по подадено цяло число n и цяло число k и връща числото, което е "закодирано" в последните k бита на n. <br />

   Вход: 15 2  | Изход: 3 <br />
   Вход: 189 3 | Изход: 5 <br />
   Вход: 189 4 | Изход: 13 <br />

3. Напишете функция, която приема цяло число n и цяло число k и връща дали k в двоичен запис (разглеждайки го без водещите 0-ли) е част от двоичния запис на n. <br />
   
   Вход: 15 3  | Изход: true <br />
   Вход: 13 5  | Изход: true <br />
   Вход: 13 7  | Изход: false <br />
 
4. Да се напише функция, която приема масив, в който всяко число се среща 2 пъти с изключение на едно число, което се среща веднъж. <br />
   Напишете функция, която приема такъв масив и връща кое е това число. <br />
   (Подсказка: използвайте побитови операции, за да постигнете линейно решение) <br />

   Вход: 9 18 9 12 18 15 12 <br />
   Изход: 15 <br />
   
5. Напишете функция, която приема масив(разглеждаме го като множество) и отпечатва всички негови подмножества. <br />

   Вход: 1 2 3   | Изход: [], [1], [2], [3], [1,2], [2,3], [1,3], [1,2,3] <br />
   Вход: 1 4 7 8 | Изход: [], [1], [4], [7], [8], [1,4], [1,7], [1,8], [4,7], [4,8], [7,8], [1,4,7], [1,7,8], [4,7,8], [1,4,7,8] <br />
   Вход: 13      | Изход: [], [13] <br />

6. Да се напише функция, която приема 3 цели числа **x**, **m** и **n** и връща числото, което се получава, ако от **x** се вземат **n** бита, започвайки от позиция **m**.<br />

   Вход: 16 3 3  | Изход:  4 //*100*00 <br />
   Вход: 16 4 2  | Изход:  2 //*10*000 <br />

7. Да се напише функция, която приема число и връща кодирано същото число по ключ, избран от вас. <br />
   Да се напише функция, която по код на число и ключ за кодиране връща оригиналното число. <br />
  
      Вход: Enter a number: 10 <br />
      Изход: Code: 51932 //you chose key 51926 <br />

Упътване: използвайте побитова операция, която е лесно обратима

8. Да се напише функция, която приема 3 цели числа **n**, **p** - позиция и бит **b** - 0 или 1 и сменя бита на **n** на позиция **p** с бита **b**.<br />

      Вход: 120 2 1  | Изход:  124 <br />
      Вход: 120 4 0  | Изход:  104 <br />

9. Да се напише функция, която приема 2 цели числа **n**, **p** - позиция и променя бита на **n** на позиция **p**.<br />

      Вход: 54 1 | Изход:  52 <br />
      Вход: 54 0 | Изход:  55 <br />


# Матрици

## Задачи

**1.** Да се напише функция, която приема матрица и връща най-малкия й елемент.

**Пример:**

Вход:
```c++
3 5 1 
6 2 4
9 0 8
```
Изход:
```c++
0
```

**2.** Да се напише функция, която приема квадратна матрица с **n** на **n** елемента отпечатва главния диагонал, след това и второстепенния.

**Пример:**

Вход:
```c++
1 2 3
4 5 6
7 8 9
```
Изход:
```c++
1 5 9
3 5 7
```

**3.** Да се напише функция, която по даден матрица отпечатва елементите ѝ на зиг-заг (първи ред отляво надясно, втори ред отдясно наляво и т.н.)

Вход:
```c++
1 2 3
4 5 6
7 8 9
```

Изход:
```c++
1 2 3 
6 5 4
7 8 9
```

**4.** Да се напише функция, която приема квадратна матрица с **n** на **n** елемента и връща дали матрицата е триъгълна, т.е. под главния диагонал има само нули.

**Пример:**

Вход:
```c++
5 1 5 
0 5 9
0 6 7
```
Изход:
```c++
0
```

Вход:
```c++
5 1 5 
0 5 9
0 0 7
```
Изход:
```c++
1
```
**5.** Да се напише функция, която транспонира квадратна матрица с **n** на **n** елемента.

**Пример:**

Вход:
```c++
1 2 3 
4 5 6 
7 8 9
```
Изход:
```c++
1 4 7
2 5 8
3 6 9
```

**6.** Една квадратна матрица от числа се нарича магически квадрат, когато всички суми, получени поотделно от сбора на елементите по всеки ред/всеки стълб/всеки от двата диагонала са равни. Да се състави функция, която приема квадратна матрица и определя дали образува магически квадрат. 

**Пример:**

Вход:
```c++
16 3 2 13
5 10 11 8
9 6 7 12
4 15 14 1
```
Изход:
```c++
yes //sum = 34
```

**7** Да се напише функция, която:
-  събира 2 матрици
- умножава матрица с число

**Пример:**

Вход:
```c++
1 2 3  
4 5 6

5 6 7
8 9 10
```

Изход:
```c++
6 8 10
12 14 16
```

```c++
1 2 3  
4 5 6

3
```

Изход:
```c++
3 6 9
12 15 18
```
**8.** Да се напише функция, която умножава 2 матрици.

Вход:
```c++
1 2
8 9
10 0
1 0
2 2

1 2 3 
4 5 2
```

Изход:
```c++
9 12 15
44 61 78
10 20 30
1 2 3
10 14 18
```
**9.** Да се напише функция, която приема матрица и принтира елементите й спираловидно, отвън навътре.

Вход:
```c++
1 2 3 
4 5 6
7 8 9
```

Изход:
```c++
1 2 3 6 9 8 7 4 5
```
**10.** Да се напише функция, която приема матрица и я обръща надясно.

Вход:
```c++
1 2 3 
4 5 6
7 8 9
```

Изход:
```c++
7 4 1
8 5 2
9 6 3
```

**11.** Напишете програма, която по въведени от потребителя размер n и двумерен масив с n * n елемента, определя дали той представлява магически квадрат.

Магически квадрат е ако сборовете по всички редове, колони и диагоналите са едни и същи.

    Пример:
    Вход:  3 
    1 2 3 1 2 3 1 2 3 

    // Това не е магически квадрат
    1 2 3 -> 6 
    1 2 3 -> 6
    1 2 3 -> 6
    | | |
    v v v
    3 6 9  

    Вход: 3
    13 8 5 14 12 10 9 16 11

    // Това е магически квадрат
            36
            /
    13  8 15 -> 36
    14 12 10 -> 36
    9  16 11 -> 36
    |  |  | \
    v  v  v  36
    36 36 36

**12.** Напишете функция, която приема матрица NxN+1 и решава системата от линейни уравнения, репрезентирана в матрицата.


*Вход*: 

3 2 5 0

2-3 4 10

2 1 1 4

*Изход: 4, -11.14, -12.85*

Тук се решава системата:

-3x + 2y - 5z = 0

2x - 3y + 4z = 10

2x + y + z=4

Тя има решение: x = 14, y = -78/4 (-11.14), z = -90/7 (-12.85).

Важно! 

Програмата трябва да засича, ако системата няма решение или има безкраен брой решения и да отпечата подходящо съобщение в този случай.

    
## Проект: Мinesweeper

Да се реализира в **конзолна** играта  **Мinesweeper**.
Целта на играта е да се разкрият всички квадратчета, които не съдържат мини , без да щракнем върху мина преди това. Разположението на мините може да се разбере логически, с помощта на цифрички, стоящи се на местата на квадратчетата след щракане върху тях. Цифрите показват колко квадратчета, в които има мини, има в съседство. Ако се щракне върху квадратче, което няма мини (стои числото 0)  в съседство, то разкрива съседните, ако някое от тези разкрити също няма мини в съседство, то също разкрива съседните квадратчета и тн...

![enter image description here](https://i.ibb.co/F4YY0ST/beginner.png)

[Онлайн версия на играта](http://minesweeperonline.com/#)


**Забележка: От вас не се изисква създаването на графичен интерфейс. Играта трябва да бъде конзолна апликация.**

В конзолата трябва да изпълнявате команди от вида:

> [command] [x coordinate] [y coordinate]

Където [command] е един от следните character-и **o** (open), **m** (mark) или **u** (unmark), а след него стоят координатите на квадратчето.

 - **open** - отваря квадратчето. Ако там седи мина - край на играта!
 - **mark** - маркира квадратчето като "мина". Ако всички мини са маркирани
   и всички други квардратчета са отворени, играта прилкючва с успех!
 - **unmark** - отмаркира квадрачето като "мина". Ако квадратчето не е било
   маркирано, то се извежда подходящо съобщение за грешка.

При започването на играта, потребителят трябва да може да избере на каква размерност да играе (3 <= N <= 10). След това трябва да избере колко мини да бъдат "скрити".
Броят трябва да е в интервала [1, 3N]. Ако някои от стойностите не са въведат правилно от потребителя, то трябва да се изведе подходящо съобщение и да бъде "приканен" да въведе отново.


